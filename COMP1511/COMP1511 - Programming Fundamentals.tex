%! TEX root = /home/lucas/Desktop/uni/COMP1511/COMP1511\ \-\ Programming Fundamentals.tex

\documentclass{article}

% Packages
\usepackage{import}
\usepackage{xcolor}
\usepackage{cancel}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{minted}
\usemintedstyle{native}
\setminted{xleftmargin=4em, autogobble, tabsize=4}
\usepackage{xcolor}

% Custom perms and combs commands
\newcommand\Myperm[2][^n]{\prescript{#1\mkern-2.5mu}{}P_{#2}}
\newcommand\Mycomb[2]{\prescript{#1\mkern-0.5mu}{}C_{#2}}

% Colors
\definecolor{yorhabg}{HTML}{131314}
\definecolor{yorhafg}{HTML}{C9C7CD}
\definecolor{yorhagrid}{HTML}{B5AF9C}
\definecolor{mred}{HTML}{D67069}
\definecolor{mblue}{HTML}{6887A1}

\usepackage[dvipsnames]{xcolor}
\definecolor{pastel_red}{RGB}{255, 173, 173}
\definecolor{pastel_orange}{RGB}{255, 214, 165}
\definecolor{pastel_yellow}{RGB}{253, 255, 182}
\definecolor{pastel_green}{RGB}{176, 217, 176}
\definecolor{pastel_blue}{RGB}{167, 199, 231}
\definecolor{pastel_purple}{RGB}{222, 218, 244}


\pagecolor{yorhabg}		% Set background color
\color{yorhafg}

\import{preamble.sty}

\usepackage[T1]{fontenc}			% Font package

\usepackage{fouriernc}

\usepackage{sectsty}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[skins, most]{tcolorbox}

\DeclareMathOperator{\sgn}{sgn}

\usepackage{tikz}
\usepackage{eso-pic}
\usetikzlibrary{calc, shadows.blur}
\usetikzlibrary{angles, quotes}
\usetikzlibrary{3d}

% Margins
\topmargin=0in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\AtBeginEnvironment{tcolorbox}{\small}

\newtcolorbox{imp}{enhanced,arc=0mm,colback=yorhabg,colframe=mred,leftrule=10mm,coltext=yorhafg,%
overlay={\node[anchor=west,outer sep=2pt] at (frame.west) {\includegraphics[width=6mm]{images/imageb.png}}; }}

\newtcolorbox{shortcut}{enhanced,arc=0mm,colback=yorhabg,colframe=mred,leftrule=10mm,coltext=yorhafg, coltitle=yorhabg, title=\texttt{Shortcut.}, 
overlay={\node[anchor=west,outer sep=2pt] at (frame.west) {\includegraphics[width=6mm]{images/imageb.png}}; }}

\newtcolorbox{question}[1]{
    enhanced, 
    colback=yorhabg,
    colframe=mblue,
    coltext=yorhafg,
    coltitle=yorhabg,
    attach boxed title to top left={yshift*=-\tcboxedtitleheight}, 
    title=\texttt{#1},
    boxed title size=title,
    boxed title style={%
        rounded corners=northeast, 
        rounded corners=northwest, 
        colback=tcbcolframe, 
        boxrule=0pt,
    },
    underlay boxed title={%
        \path[fill=tcbcolframe] (title.south west)--(title.south east) 
            to[out=0, in=180] ([xshift=5mm]title.east)--
            (title.center-|frame.east)
            [rounded corners=5pt] |- 
            (frame.north) -| cycle; 
    },
}

\newcommand\bb[1]{\textcolor{yorhafg}{\textbf{#1}}}



\title{\textbf{COMP1511: Programming Fundamentals}}
\author{L. Cheung}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Lecture 1}
	\subsection{What is COMP1511}
		\begin{itemize}
			\item Introduction to programming
			\item Learning how to write precise instructions to operate computers
			\item Assumption of no programming knowledge
		\end{itemize}

	\subsection{Introduction to C}
		\begin{minted}{c}

			#include <stdio.h>

			int main(void) {
				printf("Hello world!"\n);
				return 0;
			}

			// Output: Hello world!
		\end{minted}

\section{Lecture 2}
	\subsection{How does a computer remember things?}
		\begin{itemize}
			\item Computer memory is a big pile of on-off switches, called bits (a choice between a 1 or a 0)
			\item These bits are usually bunched into sets of 8, a byte
			\item When executing code, the CPU processes the instructions and performs basic arithmetic, but the RAM keeps track of all the data needed in those instructions and operations
		\end{itemize}

	\subsection{Variables}
		\begin{itemize}
			\item A variable is a certain allocation of bits that can be used to store information
				\begin{itemize}
					\item \textcolor{pastel_blue}{int} $\rightarrow$ integer, a whole number
						\begin{itemize}
							\item A whole number, no fractions or decimals
							\item Most commonly uses 32 bits (4 bytes)
							\item Exactly $2^{32}$ different values
							\item Finite range
						\end{itemize}
					\item \textcolor{pastel_blue}{char} $\rightarrow$ a single character
						\begin{itemize}
							\item The character holds an ASCII value, allowing characters to be read as integers
							\item Lowercase letters are only 32 numbers away from their uppercase variant (flipping one bit)
							\item Enclosed using single apostrophes
						\end{itemize}
					\item \textcolor{pastel_blue}{double} $\rightarrow$ floating point number
						\begin{itemize}
							\item A double-sized floating point number (64 bits, hence double the size of integers)
							\item Floating point means the point can be anywhere in the number
						\end{itemize}
				\end{itemize}
			\item Names are a description of what the variable is
			\item C is case sensitive, "ansWer" \textcolor{pastel_red}{$\neq$} "answer"
			\item C also reserves some words (eg. "return", "int", "double")
			\item Variables are printed using a format specifier (eg. \textcolor{pastel_green}{\%d} formats the variable in base 10, \textcolor{pastel_green}{\%lf} formats it in a double, \textcolor{pastel_green}{\%c} formats it as a character)
			\item When printing variables, they appear in the order of the specifiers given
				\begin{itemize}
					\item eg. \mintinline{c}{printf("Age: &d\n Name: %d\n", name, age)}
				\end{itemize}
		\end{itemize}

		\begin{minted}[autogobble]{c}

			#include <stdio.h>

			int main(void) {
				double grade = 99.9;
				int age = 18;			// dcc throws an error for unused variables
				char first_initial = 'H';
				grade = 97.5;
				age = 67;
				printf("%d\n", age);	// "%d" formats the variable as a decimal
			}

			// Output: 67

		\end{minted}

	\subsection{Input}
		\begin{itemize}
			\item \mintinline{c}{scanf} can be used to get an input
		\end{itemize}

		\begin{minted}[autogobble=true]{c}

			#include <stdio.h>

			int main(void) {
				int age;
				printf("Enter your age: ")
				scanf("&d", &age);
				printf("Your age is %d!\n", age);
				return 0;
				}
			
			// Output: Entered number
		\end{minted}

		\begin{itemize}
			\item The \mintinline{c}{&} symbol tells \mintinline{c}{scanf} the address of the variable in memory and where to place the given value
			\item Inserting a space before the specifier in \mintinline{scanf} tells it to ignore all preceding whitespace
		\end{itemize}

	\subsection{Constants}
		\begin{itemize}
			\item Constants are usually defined at the start of the script using \mintinline{c}{#define CONST VALUE}
		\end{itemize}

	\subsection{Maths}
		\begin{itemize}
			\item Very familiar functions
				\begin{itemize}
					\item Adding +
					\item Subtracting -
					\item Multiplication *
					\item Division /
				\end{itemize}

				\begin{minted}[autogobble]{C}

					#include <stdio.h>

					int main(void) {
						int age = 12;
						age = age + 15 * 3;
						printf("%d\n", age);
						return 0;
					}

					// Output: 57
				\end{minted}

			\item BODMAS applies to maths in C
			\item Math can be done to characters since they are just integers
			\item Adding two large integers may roll over the maximum value and produce a very small or negative number (dcc will throw warning if this occurs)
			\item There is no infinite precision when encoding a number (eg, a third cannot be represented in binary)
			\item C will maintain variable types when doing arithmetic
			\item Integers will drop whatever fraction exists, ie. rounding down
			\item \% is called the modulus and will provide the remainder from the division between two integers, eg. \verb+5 % 3 = 2+ since $\frac{5}{3} = 1 \text{ rem } 2$

			\begin{minted}[autogobble]{C}
				#include <stdio.h>

				int main(void) {
					int number = 15;
					int new_number = number % 4;
					printf("%d\n", new_number);
					return 0;
				}

				// Output: 3
			\end{minted}
		\end{itemize}

\section{Lecture 3}
	\subsection{If Statements}
		\begin{itemize}
			\item Using if statements, a program can branch between sets of instructions depending on a condition
			\item Can be used where a decision problem is a question with a yes/no answer

			\begin{minted}[autogobble]{c}
				if (condition) {
					do something;
					do something else;
				}
			\end{minted}

			\begin{question}{Example.}
				\begin{minted}[autogobble]{c}
					#include <stdio.h>

					int main(void) {
						int number;
						printf("what is your favourite number: ");
						scanf("%d", &number);
						if (number == 15) {
							printf("That's Henry's birthday!\n")
						}
						return 0;
					}

				\end{minted}
			\end{question}

		\item If statements can be chained using \mintinline{c}{else if} statements

		\begin{question}{Example.}
			\begin{minted}[autogobble]{c}

				#include <stdio.h>
				if (condition_one) {
					do something
				} else if (condition_two) {
					do different_something
				} else {
					do another_different_something
				}

			\end{minted}
		\end{question}

		\end{itemize}

	\subsection{Operators}
		\subsubsection{Relational Operators}
			\begin{itemize}
				\item Relational operators work with pairs of numbers:
					\begin{itemize}
						\item \mintinline{c}{<} less than
						\item \mintinline{c}{>} greater than
						\item \mintinline{c}{<=} less than or equal to
						\item \mintinline{c}{>=} greater than or equal to
						\item \mintinline{c}{==} equals
						\item \mintinline{c}{!=} not equal to
					\end{itemize}
				\item All these result in 0 if false and 1 if true
			\end{itemize}

		\subsubsection{Logical Operators}
			\begin{itemize}
				\item Between two expressions:
					\begin{itemize}
						\item \mintinline{c}{&&} AND: if both expressions are true then the condition is true
						\item \mintinline{c}{||} OR: if an of the two expressions are true the the condition is true
					\end{itemize}
				\item In front of an expression:
					\begin{itemize}
						\item \mintinline{c}{!} NOT: reverse the expression
					\end{itemize}

				\begin{question}{Important!!!}
					\textcolor{pastel_red}{Any value that is NOT 0 is TRUE}
				\end{question}

				\begin{question}{Example.}
					\begin{minted}[autogobble]{c}

						#include <stdio.h>

						int main(void) {
							int order = 66;
							if (order > 60 && order % 2 == 1) {
								printf("The Jedi are safe\n")
							}
							return 0;
						}

					\end{minted}
				\end{question}
				
			\item Brackets can be used to group logic statements to apply an order of operations
				\begin{itemize}
					\item Eg. \mintinline{c}{if ((condition_one && condition_two) || condition_three)}
				\end{itemize}
			\end{itemize}

		\subsubsection{Example Problem}
			We have decided to run a competition to see how many free energy drinks were given out at O- Week. Students that guess the right number of free energy drinks win! You get told whether your guess was less than, more than or the winning guess :)
			Extend the problem - if you are within 5 of the correct number, you win the guessing game.

			\begin{minted}[autogobble]{c}

				#include <stdio.h>

				int main(void) {
					int guess;
					printf("Guess how many energy drinks were given out at O-Week: ");
					scanf("%d", &guess);
					int answer = 94;
					if (guess == answer) {
						printf("Congratulations!\n");
					} else if (answer - guess <= 5 && answer - guess >= -5) {
						printf("So close, but no cigar\n");
					} else if (guess < answer) {
						printf("Too small!\n");
					} else {
						printf("That guess is too big!\n");
					}
				}

			\end{minted}

	\subsection{Looping}
		\begin{itemize}
			\item C is executed line by line starting from the main function after any #
			\item If statements allow different sections of code to be run, however while loops allow us to repeat sections of code
			\item \mintinline{c}{while()} loops can be commonly controlled in three ways:
				\begin{itemize}
					\item Count loops
						\begin{itemize}
							\item Repetition a set number of times

							\begin{minted}{c}

								#include <stdio.h>

								int main(void) {
									int i = 0;
									while (i < 3) {
										printf("Yippee!\n");
										i++;		// Increments int i by 1
									}
								}

							\end{minted}
						\end{itemize}

					\item Sentinel loops
						\begin{itemize}
							\item Repetition until a conditional is met
							\item The variable that defines whether or not the loop runs is called the sentinel
							\item The "termination condition" can be checked in the while expression

							\begin{minted}[autogobble]{c}
								
								#include <stdio.h>

								int main(void) {
									int is_correct = 0;
									while (is_correct == 0) {
										do something
									}
									return 0;
								}
								
							\end{minted}
						\end{itemize}
					\item Conditional loops
						\begin{itemize}
							\item Can also use a condition to decide to exit a loop at any time
						\end{itemize}
				\end{itemize}
		\end{itemize}

		\subsubsection{Example Problem (continued)}
			\begin{minted}[autogobble]{c}

				#include <stdio.h>

				int main(void) {
					int guess;
					printf("Guess how many energy drinks were given out at O-Week: ");
					scanf("%d", &guess);
					int answer = 94;
					int is_correct = 0;
					while (is_correct == 0) {
						if (guess == answer) {
							printf("Congratulations!\n");
							is_correct = 1;
						} else if (answer - guess <= 5 && answer - guess >= -5) {
							printf("So close, but no cigar\n");
						} else if (guess < answer) {
							printf("Too small!\n");
						} else {
							printf("That guess is too big!\n");
						}
					}
				}
			\end{minted}

\section{Lecture 4}
	
	\subsection{Examples of if statements and loops}

		\begin{question}{Simple If Statement}
			\begin{minted}[autogobble]{c}

				#include <stdio.h>

				int main(void) {
					int x = 42;
					if(x == 42 || x % 2 == 0) {
						printf("That's even, or might be the meaning of life\n");
					} else {
						printf("%d is not he meaning of life\n", x);
					}
					return 0;
				}

			\end{minted}
		\end{question}

		\begin{question}{Sentinel While Loop}
			\begin{minted}[autogobble]{c}

				#include <stdio.h>

				int main(void) {
					int beverage_number;
					int valid_order = 0;
					while (valid_order == 0) {
						printf("What beverage would you like? 0 for tea, 1 for coffee: ");
						scanf("%d", &beverage_number);
						if (beverage_number == 0) {
							printf("Enjoy your green tea!\n");
							valid_order = 1;
						} else if (beverage_number == 1) {
							printf("Enjoy your coffee!\n");
							valid_order = 1;
						} else {
							printf("That is neither tea nor coffee\n");
						}
					}
					return 0;
				}

			\end{minted}
		\end{question}

		\begin{question}{Loop de Loop}
			\begin{minted}{c}
				
				#include <stdio.h>

				int main(void) {
					int i = 0;
					int j = 0;
					while (i < 5) {
						while (j < 5) {
							printf("I am printing!\n");
							j++
						}
						i++
					}
					return 0;
				}

			\end{minted}
			
		\end{question}

		\begin{question}{Grid of Numbers}

			Goal: Print a grid of numbers as such:

			\begin{minted}{c}
				1 2 3 4 5
				1 2 3 4 5
				1 2 3 4 5
				1 2 3 4 5
			\end{minted}

			Solution:

			\begin{minted}{c}

				#include <stdio.h>

				int main(void) {
					int i = 0;
					while (i < 5) {
						int j = 0;
						while (j < 5) {
							printf("%d ", j + 1);	// Print the value of j
							j++;
						}
						i++;
						printf("\n");				// Loop this 5 times
					}
					return 0;
				}

			\end{minted}

		\end{question}

	\subsection{Structures}
		
		\begin{itemize}
			\item Structures can be used to organise related bu different components into one structure
			\item Useful in defining real world problems
			\item To create a struct:
				\begin{enumerate}
					\item Define the struct (outside the main)
					\item Declare the struct (inside the main)
					\item Initialise the struct (inside the main)
				\end{enumerate}
		\end{itemize}

		\begin{minted}{c}
				
			#include <stdio.h>

			// Define the struct
			struct coordinate {
				int x_coordinate;
				int y_coordinate;
			};

			int main(void) {
				// Declare the struct
				struct coordinate my_base;
				my_base.x_coordinate = -12;		// Initialising the struct by using its values
				my_base.y_coordinate = 65;

				struct coordinate looking;
				looking.x_coordinate = -10;
				looking.y_coordinate = 60;

				if (looking.x_coordinate > -15 && looking.x_coordinate < -10) {
					if (looking.y_coordinate >= 55 && looking.y_coordinate <= 70) {
						printf("You're getting close to my base!\n");
					} else {
						printf("You're y coordinate is off\n")
					}
				}

				printf("My base is located at x=%d, y=&d\n", my_base.x_coordinate, my_base.y_coordinate);
				return 0;
			}

		\end{minted}

	\subsection{Enumerations}

		\begin{itemize}
			\item Integer data types with a limited range of values (enumerated constants)
			\item Used to assign names to integral constants
			\item The index can be modified using flags
		\end{itemize}

		\begin{minted}{c}
			
			#include <stdio.h>

			// Declaration, NOT assignment (no equal sign)
			enum weekdays {MON, TUE, WED, THU, FRI, SAT, SUN};

			int main(void) {
				enum weekdays day;
				day = SAT;
				printf("%d", day);
				return 0;
			}

			// Output: 5
			// Explanation: Since SAT occupies the fifth index
			// of the enum (starting at 0) it returns 5

		\end{minted}

		\begin{question}{Using flags}
			\begin{minted}{c}
				
				#include <stdio.h>

				enum states {SUCCESS, FAILURE = 2, UNKNOWN}
				main(void) {
					enum states flag = UNKNOWN;
					printf("%d\n", flag);
					return = 0;
				}

				// Output: UNKNOWN = 3
				// Explanation: C will fill in the remaining constants with appropriate flags

			\end{minted}
			
		\end{question}

\end{document}
